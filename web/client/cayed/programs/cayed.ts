/**
 * This code was AUTOGENERATED using the Codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun Codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

import {
  containsBytes,
  fixEncoderSize,
  getBytesEncoder,
  type Address,
  type Instruction,
  type InstructionWithData,
  type ReadonlyUint8Array,
} from '@solana/kit'
import {
  parseInitializeInstruction,
  type ParsedInitializeInstruction,
} from '../instructions'

export const CAYED_PROGRAM_ADDRESS =
  '3jatZuig82z7WWiKJmtzeiWoK2hxQnUwfAFNcJJPXAyN' as Address<'3jatZuig82z7WWiKJmtzeiWoK2hxQnUwfAFNcJJPXAyN'>

export enum CayedInstruction {
  Initialize,
}

export function identifyCayedInstruction(
  instruction: { data: ReadonlyUint8Array } | ReadonlyUint8Array
): CayedInstruction {
  const data = 'data' in instruction ? instruction.data : instruction
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([175, 175, 109, 31, 13, 152, 155, 237])
      ),
      0
    )
  ) {
    return CayedInstruction.Initialize
  }
  throw new Error(
    'The provided instruction could not be identified as a cayed instruction.'
  )
}

export type ParsedCayedInstruction<
  TProgram extends string = '3jatZuig82z7WWiKJmtzeiWoK2hxQnUwfAFNcJJPXAyN',
> = {
  instructionType: CayedInstruction.Initialize
} & ParsedInitializeInstruction<TProgram>

export function parseCayedInstruction<TProgram extends string>(
  instruction: Instruction<TProgram> & InstructionWithData<ReadonlyUint8Array>
): ParsedCayedInstruction<TProgram> {
  const instructionType = identifyCayedInstruction(instruction)
  switch (instructionType) {
    case CayedInstruction.Initialize: {
      return {
        instructionType: CayedInstruction.Initialize,
        ...parseInitializeInstruction(instruction),
      }
    }
    default:
      throw new Error(`Unrecognized instruction type: ${instructionType as string}`)
  }
}
